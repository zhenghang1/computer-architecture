# <p align="center"> lab02 report</p>

<p align="right"> 郑航 520021911347</p>



[toc]



## <p align="center">1	实验目的</p>

+ 掌握 Xilinx 逻辑设计工具 Vivado的基本操作
+ 掌握使用 Verilog HDL进行简单的逻辑设计
+ 掌握功能仿真
+ 约束文件的使用和直接写法
+ 生成 Bitstream 文件
+ 上板验证 

其中下载验证部分暂时不做



## <p align="center">2	实验原理</p>

### 2.1 一位全加器原理分析

+ 功能：对两个输入运算位以及一个输入的进位位进行相加，并输出相加的该位结果和进位结果
+ 输入：a，b两个运算位和ci一个进位位
+ 输出：s一个结果位，c0一个进位位

一位全加器的真值表如下：

![image-20220427104319923](C:\Users\15989845233\AppData\Roaming\Typora\typora-user-images\image-20220427104319923.png)

只需要通过逻辑运算将输入输出对应起来即可，其中：

![image-20220427104435124](C:\Users\15989845233\AppData\Roaming\Typora\typora-user-images\image-20220427104435124.png)

### 2.2 四位全加器原理分析  

+ 功能：与一位全加器类似，只是其输入和输出的运算位由1位变为4位，进位位保持不变
+ 输入：a，b两个4位的运算数和ci一个进位位
+ 输出：s一个四位的结果数和c0一个进位位

其实现思路是将四个2.1中实现的一位全加器进行串联，其中：

+ 前一个一位全加器的 c0 端接入后一个一位全加器的 ci 端，第一个一位全加器的 ci 端为整个四位全加器的 ci 端，最后一个一位全加器的 c0 端为整个四位全加器的c0进位输出
+ 四位的a和b分别拆为四个部分，按顺序放于串联的四个一位全加器中，结果进行合并即可

一位加法器连接示意图：

![image-20220427105044932](C:\Users\15989845233\AppData\Roaming\Typora\typora-user-images\image-20220427105044932.png)





## <p align="center">3	实验过程</p>

### 3.1 一位全加器

​		根据2.1中所述的原理，只需要实现那两个逻辑表达式即可，我们使用四个wire型的变量s1，c1，c2和c3作为中间变量存储运算结果，并使用Verilog内置的逻辑运算单元实现我们的目标运算

​		完整代码如下：

~~~verilog
module adder_1bit(
    input a,
    input b,
    input ci,
    output s,
    output co
    );
    wire s1, c1, c2, c3;
    and (c1, a, b),
        (c2, b, ci),
        (c3, a, ci);
    xor (s1, a, b),
        (s, s1, ci);
    or (co, c1, c2, c3);
    
endmodule
~~~

### 3.2 四位全加器

​		根据2.2中所述的原理，四位全加器只是在一位全加器的基础上进行连接即可，并不需要实现任何运算，其连接图如2.2中所示，连接过程中，我们需要设置三位的ct作为中间变量，存储进位结果

​		完整代码如下：

~~~Verilog
module adder_4bits(
    input [3:0] a,
    input [3:0] b,
    input ci,
    output [3:0] s,
    output co
    );
    
    wire [2 : 0] ct;
    
    adder_1bit a1(.a(a[0]), .b(b[0]), .ci(ci), .s(s[0]), .co(ct[0])),
               a2(.a(a[1]), .b(b[1]), .ci(ct[0]), .s(s[1]), .co(ct[1])),
               a3(.a(a[2]), .b(b[2]), .ci(ct[1]), .s(s[2]), .co(ct[2])),
               a4(.a(a[3]), .b(b[3]), .ci(ct[2]), .s(s[3]), .co(co));
    
endmodule
~~~



## <p align="center">4	实验结果</p>

我们本实验只需要对四位全加器进行仿真验证即可，仿真代码实验指导书中已给出，在此不加展示

仿真波形如下：

![figure1](D:\A 上交\大二下\计算机系统结构\计算机系统结构实验\lab02\figure1.png)

可以看到，我们的四位全加器运算结果完全正确，实验成功

## <p align="center">5	工程实现</p>

Top 和xdc约束文件都已实现，详见工程文件目录中，在此也不加展示



## <p align="center">6	反思总结</p>

​		本实验实现了一位全加器和四位全加器这两个基础部件的设计与仿真。利用上个实验lab1所学习到的Verilog语法，结合一些Verilog自带的逻辑运算单元可以较简单的完成本模块的功能。在本实验中，我深刻认识到了先进行细致的原理分析然后再开始动手实现的良好实验习惯的重要性，对真值表和连接图等的分析使得我对整个实验的实现思路非常理解，完成起来也比较顺手，也能有所收获

​		实验中，通过先实现一位全加器，再进而实现四位全加器的思路非常重要，在后续的很多实验中也延续了这种设计思路，先将功能拆分并分为多个小模块，先进行实现，这样对大模块的实现就转化为了多个小模块的连接，这对于完成较复杂的模块来说是非常重要的

​		通过本次实验，我对Verilog的语法和代码逻辑更加熟悉，这对后续进行处理器模块的实现奠定了良好的基础  





